import json
import openai
import chromadb

# Initialize clients
openai_client = openai.OpenAI()
chromedb_client = chromadb.Client()

collection = chromedb_client.get_or_create_collection("real-estate-listings")

# Constants for OpenAI completion
COMPLETION_MODEL_NAME = "gpt-3.5-turbo-instruct"
MAX_ANSWER_TOKENS = 3000


def callOpenAi(prompt):
    """
    Call OpenAI API to generate text completion given a prompt.

    Args:
        prompt (str): The prompt to send to the OpenAI API.

    Returns:
        str: The completion text generated by the OpenAI API.
    """
    try:
        response = openai_client.completions.create(
            model=COMPLETION_MODEL_NAME,
            prompt=prompt,
            max_tokens=MAX_ANSWER_TOKENS
        )
        return response.choices[0].text.strip()
    except Exception as e:
        print(e)
        return ""


def generate_single_listing(listing_id):
    """
    Generate a single real estate listing.

    Args:
        listing_id (int): The ID for the listing.

    Returns:
        dict: A dictionary representing the generated listing.
    """
    json_example = """
    {
        "id": 1,
        "neighborhood": "Green Oaks",
        "price": 800000,
        "bedrooms": 2,
        "bathrooms": 2,
        "size_sqft": 2000,
        "description": "Welcome to this eco-friendly oasis...",
        "neighborhood description": "Green Oaks is a close-knit..."
    }
    """
    prompt = f"""
    Generate a new real estate listing with the ID {listing_id} with the same keys but new values in same JSON format provided below:
    
    "{json_example}"
    
    Make sure "description" is a text of up to 75 words.
    Make sure "neighborhood description" is a text of up to 50 words.
    """

    request = callOpenAi(prompt)

    # Parse the JSON string returned by the OpenAI API
    listing = json.loads(request)

    return listing


def generate_listings(num_listings, filename):
    """
    Generate multiple real estate listings and save them to a file.

    Args:
        num_listings (int): The number of listings to generate.
        filename (str): The name of the file to save the listings to.

    Returns:
        dict: A dictionary containing the generated listings.
    """
    listings = {"listings": []}

    for i in range(1, num_listings + 1):
        listing = generate_single_listing(i)
        listings["listings"].append(listing)

    with open(filename, 'w') as file:
        json.dump(listings, file, indent=4)

    return listings


def read_from_file(input_file):
    """
    Read listings from a JSON file.

    Args:
        input_file (str): The name of the file to read from.

    Returns:
        dict: A dictionary containing the listings read from the file.
    """
    with open(input_file, "r") as read_content:
        return json.load(read_content)


def process_listings(listings_map):
    """
    Process real estate listings and store them in a database.

    Args:
        listings_map (dict): A dictionary containing the listings to process.
    """
    client = chromadb.Client()
    collection = client.get_or_create_collection("real-estate-listings")

    for listing in listings_map["listings"]:
        print(listing)
        # Check if the required fields exist in the listing dictionary
        if all(field in listing for field in ["id"]):
            # Separate house and neighborhood preferences into paragraphs
            document_content = (
                "House preferences: " + listing["description"] + "\n\n" +
                "Neighborhood preferences: " +
                listing["neighborhood description"]
            )

            # Metadata map
            doc_meta_data = {
                field: listing[field]
                for field in ["neighborhood", "price", "bedrooms", "bathrooms", "size_sqft"]
            }

            # Add record
            collection.add(
                documents=[document_content],
                metadatas=[doc_meta_data],
                ids=[str(listing["id"])],
            )
        else:
            print(
                f"Skipping listing with ID {listing.get('id')} due to missing fields.")


def extract_price_range(price_range):
    """
    Extracts the minimum and maximum price range from a given string.

    Args:
        price_range (str): A string representing the price range.

    Returns:
        tuple: A tuple containing the minimum and maximum price range.
    """
    if price_range == "$600k+":
        return 600000, 999999999
    else:
        price_parts = price_range.split("-")
        price_min = int(price_parts[0].replace("$", "").replace("k", "000"))
        price_max = int(price_parts[1].replace("$", "").replace("k", "000"))
        return price_min, price_max


def query_listings(bedrooms, bathrooms, location, price_min, price_max, property_type, other_prefs):
    """
    Queries real estate listings based on specified criteria.

    Args:
        bedrooms (int): Number of bedrooms.
        bathrooms (int): Number of bathrooms.
        location (str): Location of the property.
        price_min (int): Minimum price range.
        price_max (int): Maximum price range.
        property_type (str): Type of property.
        other_prefs (str): Other preferences.

    Returns:
        dict: A dictionary containing the queried listings.
    """
    query_text = f"Bedrooms: {bedrooms}, Bathrooms: {bathrooms}, Location: {location}, Price Range: {price_min}-{price_max}, Property Type: {property_type}, Other Requirements: {other_prefs}"
    results = collection.query(query_texts=[query_text], n_results=1)
    return results


def personalize_listing(document, bedrooms, bathrooms, location, price_range, property_type, other_prefs):
    """
    Personalizes a real estate listing description based on buyer preferences.

    Args:
        document (str): Original listing description.
        bedrooms (int): Number of bedrooms.
        bathrooms (int): Number of bathrooms.
        location (str): Location of the property.
        price_range (str): Price range of the property.
        property_type (str): Type of property.
        other_prefs (str): Other preferences.

    Returns:
        str: Personalized listing description.
    """
    prompt = f"""
    Personalize the following real estate listing description based on the buyer's preferences:

    Listing Description: {document}

    Buyer Preferences:
    - Bedrooms: {bedrooms}
    - Bathrooms: {bathrooms}
    - Location: {location} 
    - Price Range: {price_range}
    - Property Type: {property_type}
    - Other Requirements: {other_prefs}
    """
    request = callOpenAi(prompt)

    return request


def generate_listing_html(listing_id, personalized_description):
    """
    Generates HTML for a real estate listing.

    Args:
        listing_id (str): ID of the listing.
        personalized_description (str): Personalized listing description.

    Returns:
        str: HTML code for the listing.
    """
    return f"""
    <div class="listing-container">
        <div class="listing" id="listing-{listing_id}">
            <h2>Listing ID: {listing_id}</h2>
            <p>{personalized_description}</p>
        </div>
    </div>
    """


def get_personalized_listings(bedrooms, bathrooms, location, price_range, property_type, other_prefs):
    """
    Retrieves personalized real estate listings based on specified criteria.

    Args:
        bedrooms (int): Number of bedrooms.
        bathrooms (int): Number of bathrooms.
        location (str): Location of the property.
        price_range (str): Price range of the property.
        property_type (str): Type of property.
        other_prefs (str): Other preferences.

    Returns:
        str: HTML code containing the personalized listings.
    """
    price_min, price_max = extract_price_range(price_range)
    results = query_listings(bedrooms, bathrooms, location,
                             price_min, price_max, property_type, other_prefs)

    if len(results["ids"]) == 0:
        return "No matching listings found for the specified preferences."

    output_html = """
    <div class="listings-container">
    """
    for i in range(len(results["ids"])):
        document = results["documents"][i]
        listing_id = results["ids"][i]
        personalized_description = personalize_listing(
            document, bedrooms, bathrooms, location, price_range, property_type, other_prefs)
        listing_html = generate_listing_html(
            listing_id, personalized_description)
        output_html += listing_html

    output_html += """
    </div>
    """

    return output_html
